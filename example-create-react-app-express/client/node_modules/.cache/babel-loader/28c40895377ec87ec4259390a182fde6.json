{"ast":null,"code":"/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule EventPropagators\n */\n\"use strict\";\n\nvar CallbackRegistry = require(\"./CallbackRegistry\");\n\nvar EventConstants = require(\"./EventConstants\");\n\nvar accumulate = require(\"./accumulate\");\n\nvar forEachAccumulated = require(\"./forEachAccumulated\");\n\nvar getListener = CallbackRegistry.getListener;\nvar PropagationPhases = EventConstants.PropagationPhases;\n/**\n * Injected dependencies:\n */\n\n/**\n * - `InstanceHandle`: [required] Module that performs logical traversals of DOM\n *   hierarchy given ids of the logical DOM elements involved.\n */\n\nvar injection = {\n  InstanceHandle: null,\n  injectInstanceHandle: function (InjectedInstanceHandle) {\n    injection.InstanceHandle = InjectedInstanceHandle;\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      injection.validate();\n    }\n  },\n  validate: function () {\n    var invalid = !injection.InstanceHandle || !injection.InstanceHandle.traverseTwoPhase || !injection.InstanceHandle.traverseEnterLeave;\n\n    if (invalid) {\n      throw new Error('InstanceHandle not injected before use!');\n    }\n  }\n};\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\n\nfunction listenerAtPhase(id, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(id, registrationName);\n}\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\n\n\nfunction accumulateDirectionalDispatches(domID, upwards, event) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    if (!domID) {\n      throw new Error('Dispatching id must not be null');\n    }\n\n    injection.validate();\n  }\n\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(domID, event, phase);\n\n  if (listener) {\n    event._dispatchListeners = accumulate(event._dispatchListeners, listener);\n    event._dispatchIDs = accumulate(event._dispatchIDs, domID);\n  }\n}\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We can not perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\n\n\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    injection.InstanceHandle.traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\n\n\nfunction accumulateDispatches(id, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(id, registrationName);\n\n    if (listener) {\n      event._dispatchListeners = accumulate(event._dispatchListeners, listener);\n      event._dispatchIDs = accumulate(event._dispatchIDs, id);\n    }\n  }\n}\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\n\n\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event.dispatchMarker, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    injection.validate();\n  }\n\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    injection.validate();\n  }\n\n  injection.InstanceHandle.traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    injection.validate();\n  }\n\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\n\n\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n  injection: injection\n};\nmodule.exports = EventPropagators;","map":{"version":3,"sources":["C:/Users/17735/Documents/itmd511/example-create-react-app-express/node_modules/react/lib/EventPropagators.js"],"names":["CallbackRegistry","require","EventConstants","accumulate","forEachAccumulated","getListener","PropagationPhases","injection","InstanceHandle","injectInstanceHandle","InjectedInstanceHandle","process","env","NODE_ENV","validate","invalid","traverseTwoPhase","traverseEnterLeave","Error","listenerAtPhase","id","event","propagationPhase","registrationName","dispatchConfig","phasedRegistrationNames","accumulateDirectionalDispatches","domID","upwards","phase","bubbled","captured","listener","_dispatchListeners","_dispatchIDs","accumulateTwoPhaseDispatchesSingle","dispatchMarker","accumulateDispatches","ignoredDirection","accumulateDirectDispatchesSingle","accumulateTwoPhaseDispatches","events","accumulateEnterLeaveDispatches","leave","enter","fromID","toID","accumulateDirectDispatches","EventPropagators","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule EventPropagators\n */\n\n\"use strict\";\n\nvar CallbackRegistry = require(\"./CallbackRegistry\");\nvar EventConstants = require(\"./EventConstants\");\n\nvar accumulate = require(\"./accumulate\");\nvar forEachAccumulated = require(\"./forEachAccumulated\");\nvar getListener = CallbackRegistry.getListener;\nvar PropagationPhases = EventConstants.PropagationPhases;\n\n/**\n * Injected dependencies:\n */\n\n/**\n * - `InstanceHandle`: [required] Module that performs logical traversals of DOM\n *   hierarchy given ids of the logical DOM elements involved.\n */\nvar injection = {\n  InstanceHandle: null,\n  injectInstanceHandle: function(InjectedInstanceHandle) {\n    injection.InstanceHandle = InjectedInstanceHandle;\n    if (\"production\" !== process.env.NODE_ENV) {\n      injection.validate();\n    }\n  },\n  validate: function() {\n    var invalid = !injection.InstanceHandle||\n      !injection.InstanceHandle.traverseTwoPhase ||\n      !injection.InstanceHandle.traverseEnterLeave;\n    if (invalid) {\n      throw new Error('InstanceHandle not injected before use!');\n    }\n  }\n};\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(id, event, propagationPhase) {\n  var registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(id, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(domID, upwards, event) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    if (!domID) {\n      throw new Error('Dispatching id must not be null');\n    }\n    injection.validate();\n  }\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(domID, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulate(event._dispatchListeners, listener);\n    event._dispatchIDs = accumulate(event._dispatchIDs, domID);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We can not perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    injection.InstanceHandle.traverseTwoPhase(\n      event.dispatchMarker,\n      accumulateDirectionalDispatches,\n      event\n    );\n  }\n}\n\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(id, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(id, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulate(event._dispatchListeners, listener);\n      event._dispatchIDs = accumulate(event._dispatchIDs, id);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event.dispatchMarker, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    injection.validate();\n  }\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    injection.validate();\n  }\n  injection.InstanceHandle.traverseEnterLeave(\n    fromID,\n    toID,\n    accumulateDispatches,\n    leave,\n    enter\n  );\n}\n\n\nfunction accumulateDirectDispatches(events) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    injection.validate();\n  }\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,\n  injection: injection\n};\n\nmodule.exports = EventPropagators;\n"]},"metadata":{},"sourceType":"script"}