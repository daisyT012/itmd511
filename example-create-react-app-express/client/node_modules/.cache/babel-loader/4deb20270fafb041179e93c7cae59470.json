{"ast":null,"code":"/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule EventPluginHub\n */\n\"use strict\";\n\nvar CallbackRegistry = require(\"./CallbackRegistry\");\n\nvar EventPluginRegistry = require(\"./EventPluginRegistry\");\n\nvar EventPluginUtils = require(\"./EventPluginUtils\");\n\nvar EventPropagators = require(\"./EventPropagators\");\n\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n\nvar accumulate = require(\"./accumulate\");\n\nvar forEachAccumulated = require(\"./forEachAccumulated\");\n\nvar invariant = require(\"./invariant\");\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\n\n\nvar eventQueue = null;\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @private\n */\n\nvar executeDispatchesAndRelease = function (event) {\n  if (event) {\n    var executeDispatch = EventPluginUtils.executeDispatch; // Plugins can provide custom behavior when dispatching events.\n\n    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);\n\n    if (PluginModule && PluginModule.executeDispatch) {\n      executeDispatch = PluginModule.executeDispatch;\n    }\n\n    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n\nvar EventPluginHub = {\n  /**\n   * Methods for injecting dependencies.\n   */\n  injection: {\n    /**\n     * @param {object} InjectedInstanceHandle\n     * @public\n     */\n    injectInstanceHandle: EventPropagators.injection.injectInstanceHandle,\n\n    /**\n     * @param {array} InjectedEventPluginOrder\n     * @public\n     */\n    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,\n\n    /**\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n     */\n    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName\n  },\n  registrationNames: EventPluginRegistry.registrationNames,\n  putListener: CallbackRegistry.putListener,\n  getListener: CallbackRegistry.getListener,\n  deleteListener: CallbackRegistry.deleteListener,\n  deleteAllListeners: CallbackRegistry.deleteAllListeners,\n\n  /**\n   * Allows registered plugins an opportunity to extract events from top-level\n   * native browser events.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @internal\n   */\n  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent) {\n    var events;\n    var plugins = EventPluginRegistry.plugins;\n\n    for (var i = 0, l = plugins.length; i < l; i++) {\n      // Not every plugin in the ordering may be loaded at runtime.\n      var possiblePlugin = plugins[i];\n\n      if (possiblePlugin) {\n        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent);\n\n        if (extractedEvents) {\n          events = accumulate(events, extractedEvents);\n        }\n      }\n    }\n\n    return events;\n  },\n\n  /**\n   * Enqueues a synthetic event that should be dispatched when\n   * `processEventQueue` is invoked.\n   *\n   * @param {*} events An accumulation of synthetic events.\n   * @internal\n   */\n  enqueueEvents: function (events) {\n    if (events) {\n      eventQueue = accumulate(eventQueue, events);\n    }\n  },\n\n  /**\n   * Dispatches all synthetic events on the event queue.\n   *\n   * @internal\n   */\n  processEventQueue: function () {\n    // Set `eventQueue` to null before processing it so that we can tell if more\n    // events get enqueued while processing.\n    var processingEventQueue = eventQueue;\n    eventQueue = null;\n    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);\n    \"production\" !== process.env.NODE_ENV ? invariant(!eventQueue, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(!eventQueue);\n  }\n};\n\nif (ExecutionEnvironment.canUseDOM) {\n  window.EventPluginHub = EventPluginHub;\n}\n\nmodule.exports = EventPluginHub;","map":{"version":3,"sources":["C:/Users/17735/Documents/itmd511/example-create-react-app-express/node_modules/react/lib/EventPluginHub.js"],"names":["CallbackRegistry","require","EventPluginRegistry","EventPluginUtils","EventPropagators","ExecutionEnvironment","accumulate","forEachAccumulated","invariant","eventQueue","executeDispatchesAndRelease","event","executeDispatch","PluginModule","getPluginModuleForEvent","executeDispatchesInOrder","isPersistent","constructor","release","EventPluginHub","injection","injectInstanceHandle","injectEventPluginOrder","injectEventPluginsByName","registrationNames","putListener","getListener","deleteListener","deleteAllListeners","extractEvents","topLevelType","topLevelTarget","topLevelTargetID","nativeEvent","events","plugins","i","l","length","possiblePlugin","extractedEvents","enqueueEvents","processEventQueue","processingEventQueue","process","env","NODE_ENV","canUseDOM","window","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule EventPluginHub\n */\n\n\"use strict\";\n\nvar CallbackRegistry = require(\"./CallbackRegistry\");\nvar EventPluginRegistry = require(\"./EventPluginRegistry\");\nvar EventPluginUtils = require(\"./EventPluginUtils\");\nvar EventPropagators = require(\"./EventPropagators\");\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n\nvar accumulate = require(\"./accumulate\");\nvar forEachAccumulated = require(\"./forEachAccumulated\");\nvar invariant = require(\"./invariant\");\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @private\n */\nvar executeDispatchesAndRelease = function(event) {\n  if (event) {\n    var executeDispatch = EventPluginUtils.executeDispatch;\n    // Plugins can provide custom behavior when dispatching events.\n    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);\n    if (PluginModule && PluginModule.executeDispatch) {\n      executeDispatch = PluginModule.executeDispatch;\n    }\n    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\nvar EventPluginHub = {\n\n  /**\n   * Methods for injecting dependencies.\n   */\n  injection: {\n\n    /**\n     * @param {object} InjectedInstanceHandle\n     * @public\n     */\n    injectInstanceHandle: EventPropagators.injection.injectInstanceHandle,\n\n    /**\n     * @param {array} InjectedEventPluginOrder\n     * @public\n     */\n    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,\n\n    /**\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n     */\n    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName\n\n  },\n\n  registrationNames: EventPluginRegistry.registrationNames,\n\n  putListener: CallbackRegistry.putListener,\n\n  getListener: CallbackRegistry.getListener,\n\n  deleteListener: CallbackRegistry.deleteListener,\n\n  deleteAllListeners: CallbackRegistry.deleteAllListeners,\n\n  /**\n   * Allows registered plugins an opportunity to extract events from top-level\n   * native browser events.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @internal\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    var events;\n    var plugins = EventPluginRegistry.plugins;\n    for (var i = 0, l = plugins.length; i < l; i++) {\n      // Not every plugin in the ordering may be loaded at runtime.\n      var possiblePlugin = plugins[i];\n      if (possiblePlugin) {\n        var extractedEvents = possiblePlugin.extractEvents(\n          topLevelType,\n          topLevelTarget,\n          topLevelTargetID,\n          nativeEvent\n        );\n        if (extractedEvents) {\n          events = accumulate(events, extractedEvents);\n        }\n      }\n    }\n    return events;\n  },\n\n  /**\n   * Enqueues a synthetic event that should be dispatched when\n   * `processEventQueue` is invoked.\n   *\n   * @param {*} events An accumulation of synthetic events.\n   * @internal\n   */\n  enqueueEvents: function(events) {\n    if (events) {\n      eventQueue = accumulate(eventQueue, events);\n    }\n  },\n\n  /**\n   * Dispatches all synthetic events on the event queue.\n   *\n   * @internal\n   */\n  processEventQueue: function() {\n    // Set `eventQueue` to null before processing it so that we can tell if more\n    // events get enqueued while processing.\n    var processingEventQueue = eventQueue;\n    eventQueue = null;\n    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !eventQueue,\n      'processEventQueue(): Additional events were enqueued while processing ' +\n      'an event queue. Support for this has not yet been implemented.'\n    ) : invariant(!eventQueue));\n  }\n\n};\n\nif (ExecutionEnvironment.canUseDOM) {\n  window.EventPluginHub = EventPluginHub;\n}\n\nmodule.exports = EventPluginHub;\n"]},"metadata":{},"sourceType":"script"}