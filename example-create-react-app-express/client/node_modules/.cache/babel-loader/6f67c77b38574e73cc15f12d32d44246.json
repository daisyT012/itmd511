{"ast":null,"code":"/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule ReactInstanceHandles\n * @typechecks static-only\n */\n\"use strict\";\n\nvar invariant = require(\"./invariant\");\n\nvar SEPARATOR = '.';\nvar SEPARATOR_LENGTH = SEPARATOR.length;\n/**\n * Maximum depth of traversals before we consider the possibility of a bad ID.\n */\n\nvar MAX_TREE_DEPTH = 100;\n/**\n * Size of the reactRoot ID space. We generate random numbers for React root\n * IDs and if there's a collision the events and DOM update system will\n * get confused. If we assume 100 React components per page, and a user\n * loads 1 page per minute 24/7 for 50 years, with a mount point space of\n * 9,999,999 the likelihood of never having a collision is 99.997%.\n */\n\nvar GLOBAL_MOUNT_POINT_MAX = 9999999;\n/**\n * Creates a DOM ID prefix to use when mounting React components.\n *\n * @param {number} index A unique integer\n * @return {string} React root ID.\n * @internal\n */\n\nfunction getReactRootIDString(index) {\n  return SEPARATOR + 'r[' + index.toString(36) + ']';\n}\n/**\n * Checks if a character in the supplied ID is a separator or the end.\n *\n * @param {string} id A React DOM ID.\n * @param {number} index Index of the character to check.\n * @return {boolean} True if the character is a separator or end of the ID.\n * @private\n */\n\n\nfunction isBoundary(id, index) {\n  return id.charAt(index) === SEPARATOR || index === id.length;\n}\n/**\n * Checks if the supplied string is a valid React DOM ID.\n *\n * @param {string} id A React DOM ID, maybe.\n * @return {boolean} True if the string is a valid React DOM ID.\n * @private\n */\n\n\nfunction isValidID(id) {\n  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;\n}\n/**\n * Checks if the first ID is an ancestor of or equal to the second ID.\n *\n * @param {string} ancestorID\n * @param {string} descendantID\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\n * @internal\n */\n\n\nfunction isAncestorIDOf(ancestorID, descendantID) {\n  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);\n}\n/**\n * Gets the parent ID of the supplied React DOM ID, `id`.\n *\n * @param {string} id ID of a component.\n * @return {string} ID of the parent, or an empty string.\n * @private\n */\n\n\nfunction getParentID(id) {\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\n}\n/**\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\n * supplied `destinationID`. If they are equal, the ID is returned.\n *\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\n * @param {string} destinationID ID of the destination node.\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\n * @private\n */\n\n\nfunction getNextDescendantID(ancestorID, destinationID) {\n  \"production\" !== process.env.NODE_ENV ? invariant(isValidID(ancestorID) && isValidID(destinationID), 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(isValidID(ancestorID) && isValidID(destinationID));\n  \"production\" !== process.env.NODE_ENV ? invariant(isAncestorIDOf(ancestorID, destinationID), 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(isAncestorIDOf(ancestorID, destinationID));\n\n  if (ancestorID === destinationID) {\n    return ancestorID;\n  } // Skip over the ancestor and the immediate separator. Traverse until we hit\n  // another separator or we reach the end of `destinationID`.\n\n\n  var start = ancestorID.length + SEPARATOR_LENGTH;\n\n  for (var i = start; i < destinationID.length; i++) {\n    if (isBoundary(destinationID, i)) {\n      break;\n    }\n  }\n\n  return destinationID.substr(0, i);\n}\n/**\n * Gets the nearest common ancestor ID of two IDs.\n *\n * Using this ID scheme, the nearest common ancestor ID is the longest common\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\n *\n * @param {string} oneID\n * @param {string} twoID\n * @return {string} Nearest common ancestor ID, or the empty string if none.\n * @private\n */\n\n\nfunction getFirstCommonAncestorID(oneID, twoID) {\n  var minLength = Math.min(oneID.length, twoID.length);\n\n  if (minLength === 0) {\n    return '';\n  }\n\n  var lastCommonMarkerIndex = 0; // Use `<=` to traverse until the \"EOL\" of the shorter string.\n\n  for (var i = 0; i <= minLength; i++) {\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\n      lastCommonMarkerIndex = i;\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\n      break;\n    }\n  }\n\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\n  \"production\" !== process.env.NODE_ENV ? invariant(isValidID(longestCommonID), 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(isValidID(longestCommonID));\n  return longestCommonID;\n}\n/**\n * Traverses the parent path between two IDs (either up or down). The IDs must\n * not be the same, and there must exist a parent path between them.\n *\n * @param {?string} start ID at which to start traversal.\n * @param {?string} stop ID at which to end traversal.\n * @param {function} cb Callback to invoke each ID with.\n * @param {?boolean} skipFirst Whether or not to skip the first node.\n * @param {?boolean} skipLast Whether or not to skip the last node.\n * @private\n */\n\n\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\n  start = start || '';\n  stop = stop || '';\n  \"production\" !== process.env.NODE_ENV ? invariant(start !== stop, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(start !== stop);\n  var traverseUp = isAncestorIDOf(stop, start);\n  \"production\" !== process.env.NODE_ENV ? invariant(traverseUp || isAncestorIDOf(start, stop), 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(traverseUp || isAncestorIDOf(start, stop)); // Traverse from `start` to `stop` one depth at a time.\n\n  var depth = 0;\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\n\n  for (var id = start;;\n  /* until break */\n  id = traverse(id, stop)) {\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\n      cb(id, traverseUp, arg);\n    }\n\n    if (id === stop) {\n      // Only break //after// visiting `stop`.\n      break;\n    }\n\n    \"production\" !== process.env.NODE_ENV ? invariant(depth++ < MAX_TREE_DEPTH, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop) : invariant(depth++ < MAX_TREE_DEPTH);\n  }\n}\n/**\n * Manages the IDs assigned to DOM representations of React components. This\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\n * order to simulate events).\n *\n * @internal\n */\n\n\nvar ReactInstanceHandles = {\n  createReactRootID: function () {\n    return getReactRootIDString(Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX));\n  },\n\n  /**\n   * Constructs a React ID by joining a root ID with a name.\n   *\n   * @param {string} rootID Root ID of a parent component.\n   * @param {string} name A component's name (as flattened children).\n   * @return {string} A React ID.\n   * @internal\n   */\n  createReactID: function (rootID, name) {\n    return rootID + SEPARATOR + name;\n  },\n\n  /**\n   * Gets the DOM ID of the React component that is the root of the tree that\n   * contains the React component with the supplied DOM ID.\n   *\n   * @param {string} id DOM ID of a React component.\n   * @return {?string} DOM ID of the React component that is the root.\n   * @internal\n   */\n  getReactRootIDFromNodeID: function (id) {\n    var regexResult = /\\.r\\[[^\\]]+\\]/.exec(id);\n    return regexResult && regexResult[0];\n  },\n\n  /**\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n   * should would receive a `mouseEnter` or `mouseLeave` event.\n   *\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\n   * nothing \"entered\" or \"left\" that element.\n   *\n   * @param {string} leaveID ID being left.\n   * @param {string} enterID ID being entered.\n   * @param {function} cb Callback to invoke on each entered/left ID.\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\n   * @internal\n   */\n  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\n\n    if (ancestorID !== leaveID) {\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\n    }\n\n    if (ancestorID !== enterID) {\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\n    }\n  },\n\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseTwoPhase: function (targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, false);\n      traverseParentPath(targetID, '', cb, arg, false, true);\n    }\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getFirstCommonAncestorID: getFirstCommonAncestorID,\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getNextDescendantID: getNextDescendantID,\n  isAncestorIDOf: isAncestorIDOf,\n  SEPARATOR: SEPARATOR\n};\nmodule.exports = ReactInstanceHandles;","map":{"version":3,"sources":["C:/Users/17735/Documents/itmd511/example-create-react-app-express/node_modules/react/lib/ReactInstanceHandles.js"],"names":["invariant","require","SEPARATOR","SEPARATOR_LENGTH","length","MAX_TREE_DEPTH","GLOBAL_MOUNT_POINT_MAX","getReactRootIDString","index","toString","isBoundary","id","charAt","isValidID","isAncestorIDOf","ancestorID","descendantID","indexOf","getParentID","substr","lastIndexOf","getNextDescendantID","destinationID","process","env","NODE_ENV","start","i","getFirstCommonAncestorID","oneID","twoID","minLength","Math","min","lastCommonMarkerIndex","longestCommonID","traverseParentPath","stop","cb","arg","skipFirst","skipLast","traverseUp","depth","traverse","ReactInstanceHandles","createReactRootID","ceil","random","createReactID","rootID","name","getReactRootIDFromNodeID","regexResult","exec","traverseEnterLeave","leaveID","enterID","upArg","downArg","traverseTwoPhase","targetID","_getFirstCommonAncestorID","_getNextDescendantID","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule ReactInstanceHandles\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar invariant = require(\"./invariant\");\n\nvar SEPARATOR = '.';\nvar SEPARATOR_LENGTH = SEPARATOR.length;\n\n/**\n * Maximum depth of traversals before we consider the possibility of a bad ID.\n */\nvar MAX_TREE_DEPTH = 100;\n\n/**\n * Size of the reactRoot ID space. We generate random numbers for React root\n * IDs and if there's a collision the events and DOM update system will\n * get confused. If we assume 100 React components per page, and a user\n * loads 1 page per minute 24/7 for 50 years, with a mount point space of\n * 9,999,999 the likelihood of never having a collision is 99.997%.\n */\nvar GLOBAL_MOUNT_POINT_MAX = 9999999;\n\n/**\n * Creates a DOM ID prefix to use when mounting React components.\n *\n * @param {number} index A unique integer\n * @return {string} React root ID.\n * @internal\n */\nfunction getReactRootIDString(index) {\n  return SEPARATOR + 'r[' + index.toString(36) + ']';\n}\n\n/**\n * Checks if a character in the supplied ID is a separator or the end.\n *\n * @param {string} id A React DOM ID.\n * @param {number} index Index of the character to check.\n * @return {boolean} True if the character is a separator or end of the ID.\n * @private\n */\nfunction isBoundary(id, index) {\n  return id.charAt(index) === SEPARATOR || index === id.length;\n}\n\n/**\n * Checks if the supplied string is a valid React DOM ID.\n *\n * @param {string} id A React DOM ID, maybe.\n * @return {boolean} True if the string is a valid React DOM ID.\n * @private\n */\nfunction isValidID(id) {\n  return id === '' || (\n    id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR\n  );\n}\n\n/**\n * Checks if the first ID is an ancestor of or equal to the second ID.\n *\n * @param {string} ancestorID\n * @param {string} descendantID\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\n * @internal\n */\nfunction isAncestorIDOf(ancestorID, descendantID) {\n  return (\n    descendantID.indexOf(ancestorID) === 0 &&\n    isBoundary(descendantID, ancestorID.length)\n  );\n}\n\n/**\n * Gets the parent ID of the supplied React DOM ID, `id`.\n *\n * @param {string} id ID of a component.\n * @return {string} ID of the parent, or an empty string.\n * @private\n */\nfunction getParentID(id) {\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\n}\n\n/**\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\n * supplied `destinationID`. If they are equal, the ID is returned.\n *\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\n * @param {string} destinationID ID of the destination node.\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\n * @private\n */\nfunction getNextDescendantID(ancestorID, destinationID) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    isValidID(ancestorID) && isValidID(destinationID),\n    'getNextDescendantID(%s, %s): Received an invalid React DOM ID.',\n    ancestorID,\n    destinationID\n  ) : invariant(isValidID(ancestorID) && isValidID(destinationID)));\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    isAncestorIDOf(ancestorID, destinationID),\n    'getNextDescendantID(...): React has made an invalid assumption about ' +\n    'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.',\n    ancestorID,\n    destinationID\n  ) : invariant(isAncestorIDOf(ancestorID, destinationID)));\n  if (ancestorID === destinationID) {\n    return ancestorID;\n  }\n  // Skip over the ancestor and the immediate separator. Traverse until we hit\n  // another separator or we reach the end of `destinationID`.\n  var start = ancestorID.length + SEPARATOR_LENGTH;\n  for (var i = start; i < destinationID.length; i++) {\n    if (isBoundary(destinationID, i)) {\n      break;\n    }\n  }\n  return destinationID.substr(0, i);\n}\n\n/**\n * Gets the nearest common ancestor ID of two IDs.\n *\n * Using this ID scheme, the nearest common ancestor ID is the longest common\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\n *\n * @param {string} oneID\n * @param {string} twoID\n * @return {string} Nearest common ancestor ID, or the empty string if none.\n * @private\n */\nfunction getFirstCommonAncestorID(oneID, twoID) {\n  var minLength = Math.min(oneID.length, twoID.length);\n  if (minLength === 0) {\n    return '';\n  }\n  var lastCommonMarkerIndex = 0;\n  // Use `<=` to traverse until the \"EOL\" of the shorter string.\n  for (var i = 0; i <= minLength; i++) {\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\n      lastCommonMarkerIndex = i;\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\n      break;\n    }\n  }\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    isValidID(longestCommonID),\n    'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s',\n    oneID,\n    twoID,\n    longestCommonID\n  ) : invariant(isValidID(longestCommonID)));\n  return longestCommonID;\n}\n\n/**\n * Traverses the parent path between two IDs (either up or down). The IDs must\n * not be the same, and there must exist a parent path between them.\n *\n * @param {?string} start ID at which to start traversal.\n * @param {?string} stop ID at which to end traversal.\n * @param {function} cb Callback to invoke each ID with.\n * @param {?boolean} skipFirst Whether or not to skip the first node.\n * @param {?boolean} skipLast Whether or not to skip the last node.\n * @private\n */\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\n  start = start || '';\n  stop = stop || '';\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    start !== stop,\n    'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.',\n    start\n  ) : invariant(start !== stop));\n  var traverseUp = isAncestorIDOf(stop, start);\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    traverseUp || isAncestorIDOf(start, stop),\n    'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' +\n    'not have a parent path.',\n    start,\n    stop\n  ) : invariant(traverseUp || isAncestorIDOf(start, stop)));\n  // Traverse from `start` to `stop` one depth at a time.\n  var depth = 0;\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\n  for (var id = start; /* until break */; id = traverse(id, stop)) {\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\n      cb(id, traverseUp, arg);\n    }\n    if (id === stop) {\n      // Only break //after// visiting `stop`.\n      break;\n    }\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      depth++ < MAX_TREE_DEPTH,\n      'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' +\n      'traversing the React DOM ID tree. This may be due to malformed IDs: %s',\n      start, stop\n    ) : invariant(depth++ < MAX_TREE_DEPTH));\n  }\n}\n\n/**\n * Manages the IDs assigned to DOM representations of React components. This\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\n * order to simulate events).\n *\n * @internal\n */\nvar ReactInstanceHandles = {\n\n  createReactRootID: function() {\n    return getReactRootIDString(\n      Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX)\n    );\n  },\n\n  /**\n   * Constructs a React ID by joining a root ID with a name.\n   *\n   * @param {string} rootID Root ID of a parent component.\n   * @param {string} name A component's name (as flattened children).\n   * @return {string} A React ID.\n   * @internal\n   */\n  createReactID: function(rootID, name) {\n    return rootID + SEPARATOR + name;\n  },\n\n  /**\n   * Gets the DOM ID of the React component that is the root of the tree that\n   * contains the React component with the supplied DOM ID.\n   *\n   * @param {string} id DOM ID of a React component.\n   * @return {?string} DOM ID of the React component that is the root.\n   * @internal\n   */\n  getReactRootIDFromNodeID: function(id) {\n    var regexResult = /\\.r\\[[^\\]]+\\]/.exec(id);\n    return regexResult && regexResult[0];\n  },\n\n  /**\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n   * should would receive a `mouseEnter` or `mouseLeave` event.\n   *\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\n   * nothing \"entered\" or \"left\" that element.\n   *\n   * @param {string} leaveID ID being left.\n   * @param {string} enterID ID being entered.\n   * @param {function} cb Callback to invoke on each entered/left ID.\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\n   * @internal\n   */\n  traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\n    if (ancestorID !== leaveID) {\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\n    }\n    if (ancestorID !== enterID) {\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\n    }\n  },\n\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseTwoPhase: function(targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, false);\n      traverseParentPath(targetID, '', cb, arg, false, true);\n    }\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getFirstCommonAncestorID: getFirstCommonAncestorID,\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getNextDescendantID: getNextDescendantID,\n\n  isAncestorIDOf: isAncestorIDOf,\n\n  SEPARATOR: SEPARATOR\n\n};\n\nmodule.exports = ReactInstanceHandles;\n"]},"metadata":{},"sourceType":"script"}