{"ast":null,"code":"/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule Danger\n * @typechecks static-only\n */\n\n/*jslint evil: true, sub: true */\n\"use strict\";\n\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n\nvar createNodesFromMarkup = require(\"./createNodesFromMarkup\");\n\nvar emptyFunction = require(\"./emptyFunction\");\n\nvar getMarkupWrap = require(\"./getMarkupWrap\");\n\nvar invariant = require(\"./invariant\");\n\nvar mutateHTMLNodeWithMarkup = require(\"./mutateHTMLNodeWithMarkup\");\n\nvar OPEN_TAG_NAME_EXP = /^(<[^ \\/>]+)/;\nvar RESULT_INDEX_ATTR = 'data-danger-index';\n/**\n * Extracts the `nodeName` from a string of markup.\n *\n * NOTE: Extracting the `nodeName` does not require a regular expression match\n * because we make assumptions about React-generated markup (i.e. there are no\n * spaces surrounding the opening tag and there is at least one attribute).\n *\n * @param {string} markup String of markup.\n * @return {string} Node name of the supplied markup.\n * @see http://jsperf.com/extract-nodename\n */\n\nfunction getNodeName(markup) {\n  return markup.substring(1, markup.indexOf(' '));\n}\n\nvar Danger = {\n  /**\n   * Renders markup into an array of nodes. The markup is expected to render\n   * into a list of root nodes. Also, the length of `resultList` and\n   * `markupList` should be the same.\n   *\n   * @param {array<string>} markupList List of markup strings to render.\n   * @return {array<DOMElement>} List of rendered nodes.\n   * @internal\n   */\n  dangerouslyRenderMarkup: function (markupList) {\n    \"production\" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyRenderMarkup(...): Cannot render markup in a Worker ' + 'thread. This is likely a bug in the framework. Please report ' + 'immediately.') : invariant(ExecutionEnvironment.canUseDOM);\n    var nodeName;\n    var markupByNodeName = {}; // Group markup by `nodeName` if a wrap is necessary, else by '*'.\n\n    for (var i = 0; i < markupList.length; i++) {\n      \"production\" !== process.env.NODE_ENV ? invariant(markupList[i], 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(markupList[i]);\n      nodeName = getNodeName(markupList[i]);\n      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';\n      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];\n      markupByNodeName[nodeName][i] = markupList[i];\n    }\n\n    var resultList = [];\n    var resultListAssignmentCount = 0;\n\n    for (nodeName in markupByNodeName) {\n      if (!markupByNodeName.hasOwnProperty(nodeName)) {\n        continue;\n      }\n\n      var markupListByNodeName = markupByNodeName[nodeName]; // This for-in loop skips the holes of the sparse array. The order of\n      // iteration should follow the order of assignment, which happens to match\n      // numerical index order, but we don't rely on that.\n\n      for (var resultIndex in markupListByNodeName) {\n        if (markupListByNodeName.hasOwnProperty(resultIndex)) {\n          var markup = markupListByNodeName[resultIndex]; // Push the requested markup with an additional RESULT_INDEX_ATTR\n          // attribute.  If the markup does not start with a < character, it\n          // will be discarded below (with an appropriate console.error).\n\n          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP, // This index will be parsed back out below.\n          '$1 ' + RESULT_INDEX_ATTR + '=\"' + resultIndex + '\" ');\n        }\n      } // Render each group of markup with similar wrapping `nodeName`.\n\n\n      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.\n      );\n\n      for (i = 0; i < renderNodes.length; ++i) {\n        var renderNode = renderNodes[i];\n\n        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {\n          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);\n          renderNode.removeAttribute(RESULT_INDEX_ATTR);\n          \"production\" !== process.env.NODE_ENV ? invariant(!resultList.hasOwnProperty(resultIndex), 'Danger: Assigning to an already-occupied result index.') : invariant(!resultList.hasOwnProperty(resultIndex));\n          resultList[resultIndex] = renderNode; // This should match resultList.length and markupList.length when\n          // we're done.\n\n          resultListAssignmentCount += 1;\n        } else if (\"production\" !== process.env.NODE_ENV) {\n          console.error(\"Danger: Discarding unexpected node:\", renderNode);\n        }\n      }\n    } // Although resultList was populated out of order, it should now be a dense\n    // array.\n\n\n    \"production\" !== process.env.NODE_ENV ? invariant(resultListAssignmentCount === resultList.length, 'Danger: Did not assign to every index of resultList.') : invariant(resultListAssignmentCount === resultList.length);\n    \"production\" !== process.env.NODE_ENV ? invariant(resultList.length === markupList.length, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(resultList.length === markupList.length);\n    return resultList;\n  },\n\n  /**\n   * Replaces a node with a string of markup at its current position within its\n   * parent. The markup must render into a single root node.\n   *\n   * @param {DOMElement} oldChild Child node to replace.\n   * @param {string} markup Markup to render in place of the child node.\n   * @internal\n   */\n  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {\n    \"production\" !== process.env.NODE_ENV ? invariant(ExecutionEnvironment.canUseDOM, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. This is likely a bug in the framework. Please report ' + 'immediately.') : invariant(ExecutionEnvironment.canUseDOM);\n    \"production\" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup); // createNodesFromMarkup() won't work if the markup is rooted by <html>\n    // since it has special semantic meaning. So we use an alternatie strategy.\n\n    if (oldChild.tagName.toLowerCase() === 'html') {\n      mutateHTMLNodeWithMarkup(oldChild, markup);\n      return;\n    }\n\n    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];\n    oldChild.parentNode.replaceChild(newChild, oldChild);\n  }\n};\nmodule.exports = Danger;","map":{"version":3,"sources":["C:/Users/17735/Documents/itmd511/example-create-react-app-express/node_modules/react/lib/Danger.js"],"names":["ExecutionEnvironment","require","createNodesFromMarkup","emptyFunction","getMarkupWrap","invariant","mutateHTMLNodeWithMarkup","OPEN_TAG_NAME_EXP","RESULT_INDEX_ATTR","getNodeName","markup","substring","indexOf","Danger","dangerouslyRenderMarkup","markupList","process","env","NODE_ENV","canUseDOM","nodeName","markupByNodeName","i","length","resultList","resultListAssignmentCount","hasOwnProperty","markupListByNodeName","resultIndex","replace","renderNodes","join","renderNode","hasAttribute","getAttribute","removeAttribute","console","error","dangerouslyReplaceNodeWithMarkup","oldChild","tagName","toLowerCase","newChild","parentNode","replaceChild","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule Danger\n * @typechecks static-only\n */\n\n/*jslint evil: true, sub: true */\n\n\"use strict\";\n\nvar ExecutionEnvironment = require(\"./ExecutionEnvironment\");\n\nvar createNodesFromMarkup = require(\"./createNodesFromMarkup\");\nvar emptyFunction = require(\"./emptyFunction\");\nvar getMarkupWrap = require(\"./getMarkupWrap\");\nvar invariant = require(\"./invariant\");\nvar mutateHTMLNodeWithMarkup = require(\"./mutateHTMLNodeWithMarkup\");\n\nvar OPEN_TAG_NAME_EXP = /^(<[^ \\/>]+)/;\nvar RESULT_INDEX_ATTR = 'data-danger-index';\n\n/**\n * Extracts the `nodeName` from a string of markup.\n *\n * NOTE: Extracting the `nodeName` does not require a regular expression match\n * because we make assumptions about React-generated markup (i.e. there are no\n * spaces surrounding the opening tag and there is at least one attribute).\n *\n * @param {string} markup String of markup.\n * @return {string} Node name of the supplied markup.\n * @see http://jsperf.com/extract-nodename\n */\nfunction getNodeName(markup) {\n  return markup.substring(1, markup.indexOf(' '));\n}\n\nvar Danger = {\n\n  /**\n   * Renders markup into an array of nodes. The markup is expected to render\n   * into a list of root nodes. Also, the length of `resultList` and\n   * `markupList` should be the same.\n   *\n   * @param {array<string>} markupList List of markup strings to render.\n   * @return {array<DOMElement>} List of rendered nodes.\n   * @internal\n   */\n  dangerouslyRenderMarkup: function(markupList) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ExecutionEnvironment.canUseDOM,\n      'dangerouslyRenderMarkup(...): Cannot render markup in a Worker ' +\n      'thread. This is likely a bug in the framework. Please report ' +\n      'immediately.'\n    ) : invariant(ExecutionEnvironment.canUseDOM));\n    var nodeName;\n    var markupByNodeName = {};\n    // Group markup by `nodeName` if a wrap is necessary, else by '*'.\n    for (var i = 0; i < markupList.length; i++) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        markupList[i],\n        'dangerouslyRenderMarkup(...): Missing markup.'\n      ) : invariant(markupList[i]));\n      nodeName = getNodeName(markupList[i]);\n      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';\n      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];\n      markupByNodeName[nodeName][i] = markupList[i];\n    }\n    var resultList = [];\n    var resultListAssignmentCount = 0;\n    for (nodeName in markupByNodeName) {\n      if (!markupByNodeName.hasOwnProperty(nodeName)) {\n        continue;\n      }\n      var markupListByNodeName = markupByNodeName[nodeName];\n\n      // This for-in loop skips the holes of the sparse array. The order of\n      // iteration should follow the order of assignment, which happens to match\n      // numerical index order, but we don't rely on that.\n      for (var resultIndex in markupListByNodeName) {\n        if (markupListByNodeName.hasOwnProperty(resultIndex)) {\n          var markup = markupListByNodeName[resultIndex];\n\n          // Push the requested markup with an additional RESULT_INDEX_ATTR\n          // attribute.  If the markup does not start with a < character, it\n          // will be discarded below (with an appropriate console.error).\n          markupListByNodeName[resultIndex] = markup.replace(\n            OPEN_TAG_NAME_EXP,\n            // This index will be parsed back out below.\n            '$1 ' + RESULT_INDEX_ATTR + '=\"' + resultIndex + '\" '\n          );\n        }\n      }\n\n      // Render each group of markup with similar wrapping `nodeName`.\n      var renderNodes = createNodesFromMarkup(\n        markupListByNodeName.join(''),\n        emptyFunction // Do nothing special with <script> tags.\n      );\n\n      for (i = 0; i < renderNodes.length; ++i) {\n        var renderNode = renderNodes[i];\n        if (renderNode.hasAttribute &&\n            renderNode.hasAttribute(RESULT_INDEX_ATTR)) {\n\n          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);\n          renderNode.removeAttribute(RESULT_INDEX_ATTR);\n\n          (\"production\" !== process.env.NODE_ENV ? invariant(\n            !resultList.hasOwnProperty(resultIndex),\n            'Danger: Assigning to an already-occupied result index.'\n          ) : invariant(!resultList.hasOwnProperty(resultIndex)));\n\n          resultList[resultIndex] = renderNode;\n\n          // This should match resultList.length and markupList.length when\n          // we're done.\n          resultListAssignmentCount += 1;\n\n        } else if (\"production\" !== process.env.NODE_ENV) {\n          console.error(\n            \"Danger: Discarding unexpected node:\",\n            renderNode\n          );\n        }\n      }\n    }\n\n    // Although resultList was populated out of order, it should now be a dense\n    // array.\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      resultListAssignmentCount === resultList.length,\n      'Danger: Did not assign to every index of resultList.'\n    ) : invariant(resultListAssignmentCount === resultList.length));\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      resultList.length === markupList.length,\n      'Danger: Expected markup to render %s nodes, but rendered %s.',\n      markupList.length,\n      resultList.length\n    ) : invariant(resultList.length === markupList.length));\n\n    return resultList;\n  },\n\n  /**\n   * Replaces a node with a string of markup at its current position within its\n   * parent. The markup must render into a single root node.\n   *\n   * @param {DOMElement} oldChild Child node to replace.\n   * @param {string} markup Markup to render in place of the child node.\n   * @internal\n   */\n  dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ExecutionEnvironment.canUseDOM,\n      'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' +\n      'worker thread. This is likely a bug in the framework. Please report ' +\n      'immediately.'\n    ) : invariant(ExecutionEnvironment.canUseDOM));\n    (\"production\" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));\n    // createNodesFromMarkup() won't work if the markup is rooted by <html>\n    // since it has special semantic meaning. So we use an alternatie strategy.\n    if (oldChild.tagName.toLowerCase() === 'html') {\n      mutateHTMLNodeWithMarkup(oldChild, markup);\n      return;\n    }\n    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];\n    oldChild.parentNode.replaceChild(newChild, oldChild);\n  }\n\n};\n\nmodule.exports = Danger;\n"]},"metadata":{},"sourceType":"script"}