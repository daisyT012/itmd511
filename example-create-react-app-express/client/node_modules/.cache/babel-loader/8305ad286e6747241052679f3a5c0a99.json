{"ast":null,"code":"/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule mergeHelpers\n *\n * requiresPolyfills: Array.isArray\n */\n\"use strict\";\n\nvar invariant = require(\"./invariant\");\n\nvar keyMirror = require(\"./keyMirror\");\n/**\n * Maximum number of levels to traverse. Will catch circular structures.\n * @const\n */\n\n\nvar MAX_MERGE_DEPTH = 36;\n/**\n * We won't worry about edge cases like new String('x') or new Boolean(true).\n * Functions are considered terminals, and arrays are not.\n * @param {*} o The item/object/value to test.\n * @return {boolean} true iff the argument is a terminal.\n */\n\nvar isTerminal = function (o) {\n  return typeof o !== 'object' || o === null;\n};\n\nvar mergeHelpers = {\n  MAX_MERGE_DEPTH: MAX_MERGE_DEPTH,\n  isTerminal: isTerminal,\n\n  /**\n   * Converts null/undefined values into empty object.\n   *\n   * @param {?Object=} arg Argument to be normalized (nullable optional)\n   * @return {!Object}\n   */\n  normalizeMergeArg: function (arg) {\n    return arg === undefined || arg === null ? {} : arg;\n  },\n\n  /**\n   * If merging Arrays, a merge strategy *must* be supplied. If not, it is\n   * likely the caller's fault. If this function is ever called with anything\n   * but `one` and `two` being `Array`s, it is the fault of the merge utilities.\n   *\n   * @param {*} one Array to merge into.\n   * @param {*} two Array to merge from.\n   */\n  checkMergeArrayArgs: function (one, two) {\n    \"production\" !== process.env.NODE_ENV ? invariant(Array.isArray(one) && Array.isArray(two), 'Critical assumptions about the merge functions have been violated. ' + 'This is the fault of the merge functions themselves, not necessarily ' + 'the callers.') : invariant(Array.isArray(one) && Array.isArray(two));\n  },\n\n  /**\n   * @param {*} one Object to merge into.\n   * @param {*} two Object to merge from.\n   */\n  checkMergeObjectArgs: function (one, two) {\n    mergeHelpers.checkMergeObjectArg(one);\n    mergeHelpers.checkMergeObjectArg(two);\n  },\n\n  /**\n   * @param {*} arg\n   */\n  checkMergeObjectArg: function (arg) {\n    \"production\" !== process.env.NODE_ENV ? invariant(!isTerminal(arg) && !Array.isArray(arg), 'Critical assumptions about the merge functions have been violated. ' + 'This is the fault of the merge functions themselves, not necessarily ' + 'the callers.') : invariant(!isTerminal(arg) && !Array.isArray(arg));\n  },\n\n  /**\n   * Checks that a merge was not given a circular object or an object that had\n   * too great of depth.\n   *\n   * @param {number} Level of recursion to validate against maximum.\n   */\n  checkMergeLevel: function (level) {\n    \"production\" !== process.env.NODE_ENV ? invariant(level < MAX_MERGE_DEPTH, 'Maximum deep merge depth exceeded. You may be attempting to merge ' + 'circular structures in an unsupported way.') : invariant(level < MAX_MERGE_DEPTH);\n  },\n\n  /**\n   * Checks that the supplied merge strategy is valid.\n   *\n   * @param {string} Array merge strategy.\n   */\n  checkArrayStrategy: function (strategy) {\n    \"production\" !== process.env.NODE_ENV ? invariant(strategy === undefined || strategy in mergeHelpers.ArrayStrategies, 'You must provide an array strategy to deep merge functions to ' + 'instruct the deep merge how to resolve merging two arrays.') : invariant(strategy === undefined || strategy in mergeHelpers.ArrayStrategies);\n  },\n\n  /**\n   * Set of possible behaviors of merge algorithms when encountering two Arrays\n   * that must be merged together.\n   * - `clobber`: The left `Array` is ignored.\n   * - `indexByIndex`: The result is achieved by recursively deep merging at\n   *   each index. (not yet supported.)\n   */\n  ArrayStrategies: keyMirror({\n    Clobber: true,\n    IndexByIndex: true\n  })\n};\nmodule.exports = mergeHelpers;","map":{"version":3,"sources":["C:/Users/17735/Documents/itmd511/example-create-react-app-express/node_modules/react/lib/mergeHelpers.js"],"names":["invariant","require","keyMirror","MAX_MERGE_DEPTH","isTerminal","o","mergeHelpers","normalizeMergeArg","arg","undefined","checkMergeArrayArgs","one","two","process","env","NODE_ENV","Array","isArray","checkMergeObjectArgs","checkMergeObjectArg","checkMergeLevel","level","checkArrayStrategy","strategy","ArrayStrategies","Clobber","IndexByIndex","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule mergeHelpers\n *\n * requiresPolyfills: Array.isArray\n */\n\n\"use strict\";\n\nvar invariant = require(\"./invariant\");\nvar keyMirror = require(\"./keyMirror\");\n\n/**\n * Maximum number of levels to traverse. Will catch circular structures.\n * @const\n */\nvar MAX_MERGE_DEPTH = 36;\n\n/**\n * We won't worry about edge cases like new String('x') or new Boolean(true).\n * Functions are considered terminals, and arrays are not.\n * @param {*} o The item/object/value to test.\n * @return {boolean} true iff the argument is a terminal.\n */\nvar isTerminal = function(o) {\n  return typeof o !== 'object' || o === null;\n};\n\nvar mergeHelpers = {\n\n  MAX_MERGE_DEPTH: MAX_MERGE_DEPTH,\n\n  isTerminal: isTerminal,\n\n  /**\n   * Converts null/undefined values into empty object.\n   *\n   * @param {?Object=} arg Argument to be normalized (nullable optional)\n   * @return {!Object}\n   */\n  normalizeMergeArg: function(arg) {\n    return arg === undefined || arg === null ? {} : arg;\n  },\n\n  /**\n   * If merging Arrays, a merge strategy *must* be supplied. If not, it is\n   * likely the caller's fault. If this function is ever called with anything\n   * but `one` and `two` being `Array`s, it is the fault of the merge utilities.\n   *\n   * @param {*} one Array to merge into.\n   * @param {*} two Array to merge from.\n   */\n  checkMergeArrayArgs: function(one, two) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      Array.isArray(one) && Array.isArray(two),\n      'Critical assumptions about the merge functions have been violated. ' +\n      'This is the fault of the merge functions themselves, not necessarily ' +\n      'the callers.'\n    ) : invariant(Array.isArray(one) && Array.isArray(two)));\n  },\n\n  /**\n   * @param {*} one Object to merge into.\n   * @param {*} two Object to merge from.\n   */\n  checkMergeObjectArgs: function(one, two) {\n    mergeHelpers.checkMergeObjectArg(one);\n    mergeHelpers.checkMergeObjectArg(two);\n  },\n\n  /**\n   * @param {*} arg\n   */\n  checkMergeObjectArg: function(arg) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !isTerminal(arg) && !Array.isArray(arg),\n      'Critical assumptions about the merge functions have been violated. ' +\n      'This is the fault of the merge functions themselves, not necessarily ' +\n      'the callers.'\n    ) : invariant(!isTerminal(arg) && !Array.isArray(arg)));\n  },\n\n  /**\n   * Checks that a merge was not given a circular object or an object that had\n   * too great of depth.\n   *\n   * @param {number} Level of recursion to validate against maximum.\n   */\n  checkMergeLevel: function(level) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      level < MAX_MERGE_DEPTH,\n      'Maximum deep merge depth exceeded. You may be attempting to merge ' +\n      'circular structures in an unsupported way.'\n    ) : invariant(level < MAX_MERGE_DEPTH));\n  },\n\n  /**\n   * Checks that the supplied merge strategy is valid.\n   *\n   * @param {string} Array merge strategy.\n   */\n  checkArrayStrategy: function(strategy) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      strategy === undefined || strategy in mergeHelpers.ArrayStrategies,\n      'You must provide an array strategy to deep merge functions to ' +\n      'instruct the deep merge how to resolve merging two arrays.'\n    ) : invariant(strategy === undefined || strategy in mergeHelpers.ArrayStrategies));\n  },\n\n  /**\n   * Set of possible behaviors of merge algorithms when encountering two Arrays\n   * that must be merged together.\n   * - `clobber`: The left `Array` is ignored.\n   * - `indexByIndex`: The result is achieved by recursively deep merging at\n   *   each index. (not yet supported.)\n   */\n  ArrayStrategies: keyMirror({\n    Clobber: true,\n    IndexByIndex: true\n  })\n\n};\n\nmodule.exports = mergeHelpers;\n"]},"metadata":{},"sourceType":"script"}