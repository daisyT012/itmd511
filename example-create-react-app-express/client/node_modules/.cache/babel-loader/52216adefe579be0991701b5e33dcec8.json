{"ast":null,"code":"/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule traverseAllChildren\n */\n\"use strict\";\n\nvar ReactComponent = require(\"./ReactComponent\");\n\nvar ReactTextComponent = require(\"./ReactTextComponent\");\n\nvar invariant = require(\"./invariant\");\n/**\n * TODO: Test that:\n * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.\n * 2. it('should fail when supplied duplicate key', function() {\n * 3. That a single child and an array with one item have the same key pattern.\n * });\n */\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\n\n\nvar traverseAllChildrenImpl = function (children, nameSoFar, indexSoFar, callback, traverseContext) {\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      var nextName = nameSoFar + ReactComponent.getKey(child, i);\n      var nextIndex = indexSoFar + subtreeCount;\n      subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);\n    }\n  } else {\n    var type = typeof children;\n    var isOnlyChild = nameSoFar === ''; // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows\n\n    var storageName = isOnlyChild ? ReactComponent.getKey(children, 0) : nameSoFar;\n\n    if (children === null || children === undefined || type === 'boolean') {\n      // All of the above are perceived as null.\n      callback(traverseContext, null, storageName, indexSoFar);\n      subtreeCount = 1;\n    } else if (children.mountComponentIntoNode) {\n      callback(traverseContext, children, storageName, indexSoFar);\n      subtreeCount = 1;\n    } else {\n      if (type === 'object') {\n        \"production\" !== process.env.NODE_ENV ? invariant(!children || children.nodeType !== 1, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(!children || children.nodeType !== 1);\n\n        for (var key in children) {\n          if (children.hasOwnProperty(key)) {\n            subtreeCount += traverseAllChildrenImpl(children[key], nameSoFar + '{' + key + '}', indexSoFar + subtreeCount, callback, traverseContext);\n          }\n        }\n      } else if (type === 'string') {\n        var normalizedText = new ReactTextComponent(children);\n        callback(traverseContext, normalizedText, storageName, indexSoFar);\n        subtreeCount += 1;\n      } else if (type === 'number') {\n        var normalizedNumber = new ReactTextComponent('' + children);\n        callback(traverseContext, normalizedNumber, storageName, indexSoFar);\n        subtreeCount += 1;\n      }\n    }\n  }\n\n  return subtreeCount;\n};\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n */\n\n\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children !== null && children !== undefined) {\n    traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n  }\n}\n\nmodule.exports = traverseAllChildren;","map":{"version":3,"sources":["C:/Users/17735/Documents/itmd511/example-create-react-app-express/node_modules/react/lib/traverseAllChildren.js"],"names":["ReactComponent","require","ReactTextComponent","invariant","traverseAllChildrenImpl","children","nameSoFar","indexSoFar","callback","traverseContext","subtreeCount","Array","isArray","i","length","child","nextName","getKey","nextIndex","type","isOnlyChild","storageName","undefined","mountComponentIntoNode","process","env","NODE_ENV","nodeType","key","hasOwnProperty","normalizedText","normalizedNumber","traverseAllChildren","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule traverseAllChildren\n */\n\n\"use strict\";\n\nvar ReactComponent = require(\"./ReactComponent\");\nvar ReactTextComponent = require(\"./ReactTextComponent\");\n\nvar invariant = require(\"./invariant\");\n\n/**\n * TODO: Test that:\n * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.\n * 2. it('should fail when supplied duplicate key', function() {\n * 3. That a single child and an array with one item have the same key pattern.\n * });\n */\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nvar traverseAllChildrenImpl =\n  function(children, nameSoFar, indexSoFar, callback, traverseContext) {\n    var subtreeCount = 0;  // Count of children found in the current subtree.\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        var nextName = nameSoFar + ReactComponent.getKey(child, i);\n        var nextIndex = indexSoFar + subtreeCount;\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          nextIndex,\n          callback,\n          traverseContext\n        );\n      }\n    } else {\n      var type = typeof children;\n      var isOnlyChild = nameSoFar === '';\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows\n      var storageName = isOnlyChild ?\n        ReactComponent.getKey(children, 0):\n        nameSoFar;\n      if (children === null || children === undefined || type === 'boolean') {\n        // All of the above are perceived as null.\n        callback(traverseContext, null, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else if (children.mountComponentIntoNode) {\n        callback(traverseContext, children, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else {\n        if (type === 'object') {\n          (\"production\" !== process.env.NODE_ENV ? invariant(\n            !children || children.nodeType !== 1,\n            'traverseAllChildren(...): Encountered an invalid child; DOM ' +\n            'elements are not valid children of React components.'\n          ) : invariant(!children || children.nodeType !== 1));\n          for (var key in children) {\n            if (children.hasOwnProperty(key)) {\n              subtreeCount += traverseAllChildrenImpl(\n                children[key],\n                nameSoFar + '{' + key + '}',\n                indexSoFar + subtreeCount,\n                callback,\n                traverseContext\n              );\n            }\n          }\n        } else if (type === 'string') {\n          var normalizedText = new ReactTextComponent(children);\n          callback(traverseContext, normalizedText, storageName, indexSoFar);\n          subtreeCount += 1;\n        } else if (type === 'number') {\n          var normalizedNumber = new ReactTextComponent('' + children);\n          callback(traverseContext, normalizedNumber, storageName, indexSoFar);\n          subtreeCount += 1;\n        }\n      }\n    }\n    return subtreeCount;\n  };\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children !== null && children !== undefined) {\n    traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n  }\n}\n\nmodule.exports = traverseAllChildren;\n"]},"metadata":{},"sourceType":"script"}