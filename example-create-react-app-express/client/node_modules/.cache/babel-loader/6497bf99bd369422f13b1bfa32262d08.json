{"ast":null,"code":"/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule ReactUpdates\n */\n\"use strict\";\n\nvar invariant = require(\"./invariant\");\n\nvar dirtyComponents = [];\nvar batchingStrategy = null;\n\nfunction ensureBatchingStrategy() {\n  \"production\" !== process.env.NODE_ENV ? invariant(batchingStrategy, 'ReactUpdates: must inject a batching strategy') : invariant(batchingStrategy);\n}\n\nfunction batchedUpdates(callback, param) {\n  ensureBatchingStrategy();\n  batchingStrategy.batchedUpdates(callback, param);\n}\n/**\n * Array comparator for ReactComponents by owner depth\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\n\n\nfunction mountDepthComparator(c1, c2) {\n  return c1._mountDepth - c2._mountDepth;\n}\n\nfunction runBatchedUpdates() {\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountDepthComparator);\n\n  for (var i = 0; i < dirtyComponents.length; i++) {\n    // If a component is unmounted before pending changes apply, ignore them\n    // TODO: Queue unmounts in the same list to avoid this happening at all\n    var component = dirtyComponents[i];\n\n    if (component.isMounted()) {\n      // If performUpdateIfNecessary happens to enqueue any new updates, we\n      // shouldn't execute the callbacks until the next render happens, so\n      // stash the callbacks first\n      var callbacks = component._pendingCallbacks;\n      component._pendingCallbacks = null;\n      component.performUpdateIfNecessary();\n\n      if (callbacks) {\n        for (var j = 0; j < callbacks.length; j++) {\n          callbacks[j].call(component);\n        }\n      }\n    }\n  }\n}\n\nfunction clearDirtyComponents() {\n  dirtyComponents.length = 0;\n}\n\nfunction flushBatchedUpdates() {\n  // Run these in separate functions so the JIT can optimize\n  try {\n    runBatchedUpdates();\n  } catch (e) {\n    // IE 8 requires catch to use finally.\n    throw e;\n  } finally {\n    clearDirtyComponents();\n  }\n}\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\n\n\nfunction enqueueUpdate(component, callback) {\n  \"production\" !== process.env.NODE_ENV ? invariant(!callback || typeof callback === \"function\", 'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(!callback || typeof callback === \"function\");\n  ensureBatchingStrategy();\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    component.performUpdateIfNecessary();\n    callback && callback();\n    return;\n  }\n\n  dirtyComponents.push(component);\n\n  if (callback) {\n    if (component._pendingCallbacks) {\n      component._pendingCallbacks.push(callback);\n    } else {\n      component._pendingCallbacks = [callback];\n    }\n  }\n}\n\nvar ReactUpdatesInjection = {\n  injectBatchingStrategy: function (_batchingStrategy) {\n    \"production\" !== process.env.NODE_ENV ? invariant(_batchingStrategy, 'ReactUpdates: must provide a batching strategy') : invariant(_batchingStrategy);\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.batchedUpdates === 'function', 'ReactUpdates: must provide a batchedUpdates() function') : invariant(typeof _batchingStrategy.batchedUpdates === 'function');\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean', 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean');\n    batchingStrategy = _batchingStrategy;\n  }\n};\nvar ReactUpdates = {\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection\n};\nmodule.exports = ReactUpdates;","map":{"version":3,"sources":["C:/Users/17735/Documents/itmd511/example-create-react-app-express/node_modules/react/lib/ReactUpdates.js"],"names":["invariant","require","dirtyComponents","batchingStrategy","ensureBatchingStrategy","process","env","NODE_ENV","batchedUpdates","callback","param","mountDepthComparator","c1","c2","_mountDepth","runBatchedUpdates","sort","i","length","component","isMounted","callbacks","_pendingCallbacks","performUpdateIfNecessary","j","call","clearDirtyComponents","flushBatchedUpdates","e","enqueueUpdate","isBatchingUpdates","push","ReactUpdatesInjection","injectBatchingStrategy","_batchingStrategy","ReactUpdates","injection","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule ReactUpdates\n */\n\n\"use strict\";\n\nvar invariant = require(\"./invariant\");\n\nvar dirtyComponents = [];\n\nvar batchingStrategy = null;\n\nfunction ensureBatchingStrategy() {\n  (\"production\" !== process.env.NODE_ENV ? invariant(batchingStrategy, 'ReactUpdates: must inject a batching strategy') : invariant(batchingStrategy));\n}\n\nfunction batchedUpdates(callback, param) {\n  ensureBatchingStrategy();\n  batchingStrategy.batchedUpdates(callback, param);\n}\n\n/**\n * Array comparator for ReactComponents by owner depth\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountDepthComparator(c1, c2) {\n  return c1._mountDepth - c2._mountDepth;\n}\n\nfunction runBatchedUpdates() {\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n\n  dirtyComponents.sort(mountDepthComparator);\n\n  for (var i = 0; i < dirtyComponents.length; i++) {\n    // If a component is unmounted before pending changes apply, ignore them\n    // TODO: Queue unmounts in the same list to avoid this happening at all\n    var component = dirtyComponents[i];\n    if (component.isMounted()) {\n      // If performUpdateIfNecessary happens to enqueue any new updates, we\n      // shouldn't execute the callbacks until the next render happens, so\n      // stash the callbacks first\n      var callbacks = component._pendingCallbacks;\n      component._pendingCallbacks = null;\n      component.performUpdateIfNecessary();\n      if (callbacks) {\n        for (var j = 0; j < callbacks.length; j++) {\n          callbacks[j].call(component);\n        }\n      }\n    }\n  }\n}\n\nfunction clearDirtyComponents() {\n  dirtyComponents.length = 0;\n}\n\nfunction flushBatchedUpdates() {\n  // Run these in separate functions so the JIT can optimize\n  try {\n    runBatchedUpdates();\n  } catch (e) {\n    // IE 8 requires catch to use finally.\n    throw e;\n  } finally {\n    clearDirtyComponents();\n  }\n}\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component, callback) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !callback || typeof callback === \"function\",\n    'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' +\n    '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +\n    'isn\\'t callable.'\n  ) : invariant(!callback || typeof callback === \"function\"));\n  ensureBatchingStrategy();\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    component.performUpdateIfNecessary();\n    callback && callback();\n    return;\n  }\n\n  dirtyComponents.push(component);\n\n  if (callback) {\n    if (component._pendingCallbacks) {\n      component._pendingCallbacks.push(callback);\n    } else {\n      component._pendingCallbacks = [callback];\n    }\n  }\n}\n\nvar ReactUpdatesInjection = {\n  injectBatchingStrategy: function(_batchingStrategy) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      _batchingStrategy,\n      'ReactUpdates: must provide a batching strategy'\n    ) : invariant(_batchingStrategy));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof _batchingStrategy.batchedUpdates === 'function',\n      'ReactUpdates: must provide a batchedUpdates() function'\n    ) : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof _batchingStrategy.isBatchingUpdates === 'boolean',\n      'ReactUpdates: must provide an isBatchingUpdates boolean attribute'\n    ) : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection\n};\n\nmodule.exports = ReactUpdates;\n"]},"metadata":{},"sourceType":"script"}